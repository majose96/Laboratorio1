#include <stdio.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#ifndef ROT64
#define ROT64(x, y) (((x) << (y)) | ((x) >> (64 - (y)))) // voy corriendo bits
#endif
int main(){}
void keccak(uint64_t A[25]) // uint 64_t A[] vector que se llena con archivo
{
    // constants
    const uint64_t RC[24] = {
        0x0000000000000001, 0x0000000000008082, 0x800000000000808a,  // se usa para iota
        0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
        0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
        0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
        0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
        0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
        0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
        0x8000000000008080, 0x0000000080000001, 0x8000000080008008
    };
    const int rotc[24] = {
        1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14, // se usa para pi y rho... son posiciones fijas que toma el vector A 
        27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44  //y nos ahorra hacer todos los calculos que pensabamos en el laboratorio
    };
    const int piln[24] = {
        10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4,   // sirve tambien para hacer las operaciones de pi y rho
        15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1
    };

        //variables
       int i, j, r;
       uint64_t t, Aux[5];

       // numero de iteracciones
       for (r = 0; r < 24; r++) {

        // Theta
           for (i = 0; i < 5; i++)
               Aux[i] = A[i] ^ A[i + 5] ^ A[i + 10] ^ A[i + 15] ^ A[i + 20];

           for (i = 0; i < 5; i++) {
               t = Aux[(i + 4) % 5] ^ ROT64(Aux[(i + 1) % 5], 1);
               for (j = 0; j < 25; j += 5)
                   A[j + i] ^= t;
           }

           // Rho Pi
           t = A[1];
           for (i = 0; i < 24; i++) {
               j = piln[i];
               Aux[0] = A[j];
               A[j] = ROT64(t, rotc[i]);
               t = Aux[0];
           }

           //  Chi
           for (j = 0; j < 25; j += 5) {
               for (i = 0; i < 5; i++)
                   Aux[i] = A[j + i];
               for (i = 0; i < 5; i++)
                   A[j + i] ^= (~Aux[(i + 1) % 5]) & Aux[(i + 2) % 5];
           }

           //  Iota
           A[0] ^= RC[r];
       }
   }
